from events_commands.commands import Command, MovementCommand, MoveCommand, JumpCommand
from events_commands.events import LandedEvent, StartedFallingEvent, AddMomentumEvent as AME
from enums.entity_enums import HorizontalMovementState as HMS, VerticalMovementState as VMS
from enums.entity_enums import DirectionState as DS


class PlayerPhysics:
    # for making this a flying vs other type, maybe just have a swappable grav component or such that is swapped depending on the type of entity in entity category
    def __init__(self, context=None):
        self.context = context

    def update(self, data, context=None):
        context = context or self.context
        if context is None:
            raise ValueError("PlayerPhysics.update needs a context value")
        # will eventually receive tile context too to know if it collides with walls/floors
        # haven't decided if it only gets tile context, or any other relevant context info
        # for now, its the startup context it has access to with tile context in that
        events = []
        # update position based on velocity
        # data.position[0] += data.velocity[0]

        # returns a dict with all tiles around the player as values, keys being their relative position

        returned_events = self.horizontal_motion(data, context)
        events.extend(returned_events)
        returned_event = self.vertical_motion(data, context)
        if returned_event:
            events.append(returned_event)
        # if there are any events after this, added here. might not actually be any, but jump will have some state change events probably

        # data.position[1] += data.velocity[1]
        # gravity and other physics would go here

        # once tile context is added, check for collisions and then implement a backstep if neeed
        return events  # return any events generated by physics updates, just events for now

    def horizontal_motion(self, data, context):
        # will eventually implement collision detection here so that
        # if the speed is greater than brick size, it will divide the movement into many smaller movements and check each for collision, ending movement if collision detected
        # need to create code to handle a sprites position overlapping tiles, grabbing those tiles it's not overlapping with. for that, will need to edit tile context to allow that.

        #
        movement = data.velocity[0]
        # data.position[0] += movement
        movement_increments = abs(movement) // 8
        initial_movement = data.velocity[0] % 8
        data.position[0] += initial_movement
        if self.check_tile_collisions(data, context):
            self.stepback(data, -movement, context)
            self.check_horizontal_momentum(data)
            # check horizontal momentum, then return ending movement because collision detected
            return []

        chunk_movement = 8 if movement > 0 else -8
        for _ in range(movement_increments):
            data.position[0] += chunk_movement
            if self.check_tile_collisions(data, context):
                self.stepback(data, -movement, context)
                break
            # end movement if tile collision detected

        self.check_horizontal_momentum(data)

        return []
        # for now just check collision with all, no need to make it only check the sides it could move into based on direction

    def check_horizontal_momentum(self, data):
        # this adjusts speed horizontally, so if an entity is launched beyond its speed it can gradually return to normal speed. come up with something to handle lots of momentum later possibly, if it matters
        # don't need horizontal, as gravity already handles that

        if data.h_movement_state == HMS.WALKING:
            speed = -1 * data.move_speed if data.direction_state == DS.LEFT else data.move_speed
        else:
            speed = 0

        if data.velocity[0] != speed:
            if data.velocity[0] < speed:
                data.velocity[0] += 1
            elif data.velocity[0] > speed:
                data.velocity[0] -= 1

    def check_tile_collisions(self, data, context):
        x, y = int(data.position[0]), int(data.position[1])
        tiles = context.tile_context.get_touching_bricks(x, y, data.w_h[0], data.w_h[1])
        return self.has_tile_collision(tiles, context)

    def has_tile_collision(self, tiles, context):
        for tile in tiles:
            if tile[0] >= context.collideable_tile_x:
                return True
        return False

    def vertical_motion(self, data, context):
        event = None
        data.position[1] = int(data.position[1] - data.velocity[1])



        match data.v_movement_state:
            case VMS.JUMPING | VMS.FALLING:
                if self.check_tile_collisions(data, context):
                    self.stepback(data, data.velocity[1], context, axis=1)
                    if self.updward_momentum(data):

                        event = StartedFallingEvent()
                        data.velocity[1] = 0
                    else:
                        # hit head/ceiling
                        # return swap to falling event
                        event = LandedEvent()
                        data.velocity[1] = 0
                        return event

            case _:
                ground_beneath = self.ground_beneath_player(data, context)
                if ground_beneath:
                    data.velocity[1] = 0
                    return event
                else:
                    event = StartedFallingEvent()

        # it gets to update gravity if not on ground
        self.update_gravity(data, context)
        return event

    def ground_beneath_player(self, data, context):
        x_start = int(data.position[0])

        y_value = int(data.position[1] + data.w_h[1])
        bricks = context.tile_context.get_touching_bricks(x_start, y_value, data.w_h[0], 1)
        return self.has_tile_collision(bricks, context)


    def updward_momentum(self, data):
        if data.velocity[1] < 0:
            return False
        return True

    def update_gravity(self, data, context):
        # simple gravity, add proper gravity later
        gravity = -0.4
        terminal_velocity = -5
        data.velocity[1] += gravity
        if data.velocity[1] < terminal_velocity:
            data.velocity[1] = terminal_velocity




    def stepback(self, data, reverse, context, axis=0):
        sign = -1 if reverse < 0 else 1
        # moves back one pixel at a time until no longer colliding
        while self.check_tile_collisions(data, context):
            data.position[axis] += sign

    def handle_event(self, event, data = None):
        match event:
            case AME():
                self.add_momentum_event(event)

        return []

    def add_momentum_event(self, event):
        entity = event.entity
        momentum = event.momentum  # tuple (x_momentum, y_momentum)
        entity.velocity[0] += momentum[0]
        entity.velocity[1] += momentum[1]


    def handle_command(self, command, data):

        # returns a tuple of events and commands
        match command:
            # if commands get to big divide into movment commands and such but for now just use in handle command and then separate logic code
            case MoveCommand():
                return self.process_move_command(command, data)
            case JumpCommand():
                # implement jump logic later
                self.jump(command, data)
        return ([], [])

    def jump(self, command, data):
        # actually probably don't need the command
        data.velocity[1] = data.jump_strength

    def process_move_command(self, command, data):

        match command.direction:
            case DS.LEFT:
                data.velocity[0] = -data.move_speed
            case DS.RIGHT:
                data.velocity[0] = data.move_speed
            case DS.HALT:
                data.velocity[0] = 0
        return ([], [])  # no events or commands to return for now
    # possibly remove return from here if no events or commands are generated at all in the future
