from events_commands.commands import Command, MovementCommand, MoveCommand, JumpCommand
from player.player_enums import DirectionState as DS


class PlayerPhysics:
    def __init__(self, context=None):
        self.context = context

    def update(self, data, context=None):
        context = context or self.context
        if context is None:
            raise ValueError("PlayerPhysics.update needs a context value")
        # will eventually receive tile context too to know if it collides with walls/floors
        # haven't decided if it only gets tile context, or any other relevant context info
        # for now, its the startup context it has access to with tile context in that
        events = []
        # update position based on velocity
        # data.position[0] += data.velocity[0]

        # returns a dict with all tiles around the player as values, keys being their relative position

        returned_events = self.horizontal_motion(data, context)
        events.extend(returned_events)
        return_events = self.vertical_motion(data, context)
        events.extend(return_events)
        # if there are any events after this, added here. might not actually be any, but jump will have some state change events probably

        # data.position[1] += data.velocity[1]
        # gravity and other physics would go here

        # once tile context is added, check for collisions and then implement a backstep if neeed
        return events  # return any events generated by physics updates, just events for now

    def horizontal_motion(self, data, context):
        # will eventually implement collision detection here so that
        # if the speed is greater than brick size, it will divide the movement into many smaller movements and check each for collision, ending movement if collision detected
        # need to create code to handle a sprites position overlapping tiles, grabbing those tiles it's not overlapping with. for that, will need to edit tile context to allow that.
        movement = data.velocity[0]
        data.position[0] += movement
        if self.check_tile_collisions(data, context):
            self.stepback(data, -movement, context)
        return []
        # for now just check collision with all, no need to make it only check the sides it could move into based on direction

    def check_tile_collisions(self, data, context):
        tiles = context.tile_context.get_touching_bricks(data.position[0], data.position[1], 8, 8)
        # 8x8 is player size for now, will need to adjust later for dynamic size
        for tile in tiles:
            if tile[0] >= context.collideable_tile_x:
                return True
        return False

    def vertical_motion(self, data, context):
        return []  # no vertical motion yet

    def stepback(self, data, reverse, context, axis=0):
        sign = -1 if reverse < 0 else 1
        # moves back one pixel at a time until no longer colliding
        while self.check_tile_collisions(data, context):
            data.position[axis] += sign

    def handle_event(self, event, data):
        pass

    def handle_command(self, command, data):

        # returns a tuple of events and commands
        match command:
            # if commands get to big divide into movment commands and such but for now just use in handle command and then separate logic code
            case MoveCommand():
                return self.process_move_command(command, data)
            case JumpCommand():
                # implement jump logic later
                pass
        return ([], [])

    def process_move_command(self, command, data):

        match command.direction:
            case DS.LEFT:
                data.velocity[0] = -data.move_speed
            case DS.RIGHT:
                data.velocity[0] = data.move_speed
            case DS.HALT:
                data.velocity[0] = 0
        return ([], [])  # no events or commands to return for now
    # possibly remove return from here if no events or commands are generated at all in the future
