from events_commands.commands import Command, MovementCommand, MoveCommand, JumpCommand
from events_commands.events import LandedEvent, StartedFallingEvent, AddMomentumEvent as AME
from enums.entity_enums import MovementState as MS
from enums.entity_enums import DirectionState as DS


class PlayerPhysics:
    # for making this a flying vs other type, maybe just have a swappable grav component or such that is swapped depending on the type of entity in entity category
    def __init__(self, context=None):
        self.context = context

    def update(self, data, context=None):
        context = context or self.context
        if context is None:
            raise ValueError("PlayerPhysics.update needs a context value")
        # will eventually receive tile context too to know if it collides with walls/floors
        # haven't decided if it only gets tile context, or any other relevant context info
        # for now, its the startup context it has access to with tile context in that
        events = []
        # update position based on velocity
        # data.position[0] += data.velocity[0]

        # returns a dict with all tiles around the player as values, keys being their relative position

        returned_events = self.horizontal_motion(data, context)
        events.extend(returned_events)
        returned_event = self.vertical_motion(data, context)
        self.secondary_momentum_update(data, context)
        if returned_event:
            events.append(returned_event)
        # if there are any events after this, added here. might not actually be any, but jump will have some state change events probably

        # data.position[1] += data.velocity[1]
        # gravity and other physics would go here

        # once tile context is added, check for collisions and then implement a backstep if neeed
        return events  # return any events generated by physics updates, just events for now

    def horizontal_motion(self, data, context):
        # will eventually implement collision detection here so that
        # if the speed is greater than brick size, it will divide the movement into many smaller movements and check each for collision, ending movement if collision detected
        # need to create code to handle a sprites position overlapping tiles, grabbing those tiles it's not overlapping with. for that, will need to edit tile context to allow that.
        movement = data.velocity[0]
        data.position[0] += movement
        if self.check_tile_collisions(data, context):
            self.stepback(data, -movement, context)
        return []
        # for now just check collision with all, no need to make it only check the sides it could move into based on direction

    def secondary_momentum_update(self, data, context):
        # apply secondary momentum like knockback
        data.position[0] += data.secondary_momentum[0]
        if self.check_tile_collisions(data, context):
            self.stepback(data, data.secondary_momentum[0], context, axis=0)
        data.position[1] += data.secondary_momentum[1]

        if self.check_tile_collisions(data, context):
            self.stepback(data, data.secondary_momentum[1], context, axis=1)



    def check_tile_collisions(self, data, context):
        x, y = int(data.position[0]), int(data.position[1])
        tiles = context.tile_context.get_touching_bricks(x, y, data.w_h[0], data.w_h[1])
        return self.has_tile_collision(tiles, context)

    def has_tile_collision(self, tiles, context):
        for tile in tiles:
            if tile[0] >= context.collideable_tile_x:
                return True
        return False

    def vertical_motion(self, data, context):
        event = None
        data.position[1] = int(data.position[1] - data.velocity[1])



        match data.movement_state:
            case MS.JUMPING | MS.FALLING:
                if self.check_tile_collisions(data, context):
                    self.stepback(data, data.velocity[1], context, axis=1)
                    if self.updward_momentum(data):

                        event = StartedFallingEvent()
                        data.velocity[1] = 0
                    else:
                        # hit head/ceiling
                        # return swap to falling event
                        event = LandedEvent()
                        data.velocity[1] = 0
                        return event

            case _:
                ground_beneath = self.ground_beneath_player(data, context)
                if ground_beneath:
                    data.velocity[1] = 0
                    return event
                else:
                    event = StartedFallingEvent()

        # it gets to update gravity if not on ground
        self.update_gravity(data, context)
        return event

    def ground_beneath_player(self, data, context):
        x_start = int(data.position[0])

        y_value = int(data.position[1] + data.w_h[1])
        bricks = context.tile_context.get_touching_bricks(x_start, y_value, data.w_h[0], 1)
        return self.has_tile_collision(bricks, context)


    def updward_momentum(self, data):
        if data.velocity[1] < 0:
            return False
        return True

    def update_gravity(self, data, context):
        # simple gravity, add proper gravity later
        gravity = -0.4
        terminal_velocity = -5
        data.velocity[1] += gravity
        if data.velocity[1] < terminal_velocity:
            data.velocity[1] = terminal_velocity




    def stepback(self, data, reverse, context, axis=0):
        sign = -1 if reverse < 0 else 1
        # moves back one pixel at a time until no longer colliding
        while self.check_tile_collisions(data, context):
            data.position[axis] += sign

    def handle_event(self, event):
        match event:
            case AME():
                self.apply_momentum_event(event)

    def apply_momentum(self, event):
        event.entity.secondary_momentum[0] += event.momentum_vector[0]
        event.entity.secondary_momentum[1] += event.momentum_vector[1]


    def handle_command(self, command, data):

        # returns a tuple of events and commands
        match command:
            # if commands get to big divide into movment commands and such but for now just use in handle command and then separate logic code
            case MoveCommand():
                return self.process_move_command(command, data)
            case JumpCommand():
                # implement jump logic later
                self.jump(command, data)
        return ([], [])

    def jump(self, command, data):
        # actually probably don't need the command
        data.velocity[1] = data.jump_strength

    def process_move_command(self, command, data):

        match command.direction:
            case DS.LEFT:
                data.velocity[0] = -data.move_speed
            case DS.RIGHT:
                data.velocity[0] = data.move_speed
            case DS.HALT:
                data.velocity[0] = 0
        return ([], [])  # no events or commands to return for now
    # possibly remove return from here if no events or commands are generated at all in the future
