from ..events_commands.commands import Command, MovementCommand, MoveCommand, JumpCommand
from player_enums import DirectionState as DS


class PlayerPhysics:
    def __init__(self):
        pass

    def update(self, data):
        # will eventually receive tile context too to know if it collides with walls/floors
        # update position based on velocity
        data.position[0] += data.velocity[0]
        data.position[1] += data.velocity[1]
        # gravity and other physics would go here

        # once tile context is added, check for collisions and then implement a backstep if neeed
        return []  # return any events generated by physics updates, just events for now

    def handle_event(self, event, data):
        pass

    def handle_command(self, command, data):

        # returns a tuple of events and commands
        match command:
            # if commands get to big divide into movment commands and such but for now just use in handle command and then separate logic code
            case MoveCommand():
                return self.process_move_command(command, data)
            case JumpCommand():
                # implement jump logic later
                pass
        return ([], [])

    def process_move_command(self, command, data):

        match command.direction:
            case DS.LEFT:
                data.velocity[0] = -data.move_speed
            case DS.RIGHT:
                data.velocity[0] = data.move_speed
            case DS.HALT:
                data.velocity[0] = 0
        return ([], [])  # no events or commands to return for now
    # possibly remove return from here if no events or commands are generated at all in the future
